<!DOCTYPE html>
<html>
<head>
    <meta content="text/html; charset=UTF-8" http-equiv="content-type"/>
    <title>Peal Webapp</title>
</head>
<body class="lift:content_id=main">
<div id="main" class="lift:surround?with=default;at=content">

    <!--<span class="lift:embed?what=_embedme">-->
    <!--replaced with embedded content-->
    <!--</span>-->
    <div class="col-sm-12">
        <h4>Getting started</h4>

        <p>
            PEALT input consists of text statements delimited by \n (NEWLINE) characters. The sections of the input
            are divided by keywords, POLICIES,
            POLICY_SETS, CONDITIONS, DOMAIN_SPECIFICS (optional), and ANALYSES. The details of the language grammar is
            documented in the aforementioned technical report. This guide aims to give some basic ideas to get users started.

        </p>


        <!--<h4>POLICIES</h4>-->

        <p>
            Multiple input policies can be defined in this section. A valid policy may be,
        </p>

        <pre>b1 = min ((q1 0.2) (q2 0.4) (q3 0.9)) default 1</pre>

        <p>Here, b1 is the policy name, min is the operator, followed by zero or more rules in a pair of brackets. Each
            rule is a
            tuple of (predicate name, score).
            Finally, the statement ends with the "default" keyword and a default score.
            The names of predicates, policies, policy sets, and conditions are strings starting with a letter,
            followed by more
            letters or numbers.
        </p>

        <p>

            Predicates do not need to be declared. The Peal parser will read in a policy and automatically recognise the
            left
            hand side of the rule tuples as predicates.

            A predicate is a boolean value, a true value means the associated score is applicable, otherwise it means
            the tuple has no effect in the container policy.
            If all predicates are false, then the policy is assigned the default score.
            If a predicate name appears in more than one policies, it simply means
            the same boolean variable controls application of associated scores in those policies.
        </p>

        <p>
            If the operator is changed to +, *, or max, the score of the policy is aggregated accordingly.
        </p>

        <p>
            Note that while violating this does not cause an error, the policy name should be unique. Internally,
            policies are
            held in a map with policy names as the key, thus the policies will be overridden by later ones of the same
            name.
        </p>

        <p>At the risk of spelling out the obvious, this statement says b1 is evaluated to the minimum
            of all scores where the predicates are true. If all predicates are false, then b1 is assigned the default
            score 1.
        </p>


        <!--<h4>POLICY_SETS</h4>-->

        <p>
            Policy Sets aggregate the scores of previously defined policies. A policy set can simply equal to a policy, or
            aggregation of two policy sets by max or min operator (binary). For example, assuming we have policies b1, b2, and b3, then we can do,
        </p>

        <pre>pSet1 = b1
pSet2 = max(b1, b2)</pre>

       <p>If we wish to express a nested structure, we can achieve so by referring to already declared variable,
           as the policy set operators are binary. For example,</p>

        <pre>pSet3 = min(b3, pSet2)</pre>

        <p>is the allowed input to express pSet3 = min(b3, max(b1, b2)).</p>

        <!--<h4>CONDITIONS</h4>-->

        <!--<h4>DOMAIN_SPECIFICS</h4>-->
        <p>
            The domain specifics section contains Z3 specific code that will simply be appended to the end of generated code.
            It is users' responsibilities to enter valid inputs accepted by the Z3 SMT solver.
            And that Boolean predicates that occur in rules do not (in fact must not) be redeclared as Boolean predicates
            in DOMAIN_SPECIFICS if they are referred to in that part.
        </p>

        <p>Supported analyses, conditions and their usage are documented in the technical report.</p>
        <!--<h4>ANALYSES</h4>-->

        <!--<p>-->
            <!--Supported analyses are:-->
        <!--</p>-->
        <!--<pre>analysis1 = always_true? cond1</pre>-->
        <!--<p>This defines an analysis (called analysis1) that checked cond1 is always true. If it's possible to make-->
        <!--cond1 false, a counter example will be shown in the output.</p>-->

        <!--<p>Intuitively, always_false? cond1 checks if cond1 is always false, and satisfiable? cond1 checks if it's possible-->
        <!--to make cond1 true (essentially it's !always_false)</p>-->

        <h4>PEALT usage constraints</h4>

        <p>We now describe the illicit combinations, which we want to automatically disable in future version of the
            tool:</p>

        <p>
            Usage constraint 1: explicit synthesis should not be used when any + policy occurring within an analysis
            contains some negative or non-constant score or when any such * policy has scores not in the unit interval
            [0,1]; it should also not be used when any min or max policy occurring in an analysis contains some
            non-constant
            score (negative but constant ones are OK then).
        </p>

        <p>
            Usage constraint 2: symbolic synthesis should not be used when any min or max policy occurring within an
            analysis contains some non-constant score (negative but constant ones are OK then).
        </p>

        <p>
            <!--It is therefore safe to use explicit synthesis for positive, constant scores only.-->
            For example, it is safe to use explicit synthesis for constant scores in the unit interval.
            <!--can currently not be generated  -->
            <!--domain specific information contains complex features such as  quantification or functions.-->
            Also, it is safe to use symbolic synthesis for both positive and negative scores
            when only + and * policies have non-constant scores.
        </p>

        <p>
            In this early alpha version of PEALT, the app will return no result if any stage of processing exhausts the system
            resource. For example,
            PEALT may produce no output if a model generated for <i>n</i> greater than 20 of majority voting is supplied.
        </p>

        <p>Additionally, pretty printed output is currently not available for inputs with domain specifics,
            and symbolic synthesis results. This problem will be rectified in due course.
        </p>

        <p>
            Please contact Jim Kuo (google for contact info) with any queries or feedback regarding the PEALT tool.
        </p>

        <!--<h3>Abstract</h3>-->
        <!--<p>This little application demonstrates the logical synthesis from Peal policies.</p>-->
        <!--<p>We explore how best to do the synthesis of logical formula that capture whether a-->
        <!--Peal policy evaluates below or strictly above some threshold. We confine our attention for now-->
        <!--to scores that are non-negative. We will consider the consistency of conjunctions of predicates,-->
        <!--and investigate what research issues and trade-offs such consideration brings to this synthesis process.</p>-->
        <!--<p>By Michael Huth and Jim Huan-Pu Kuo</p>-->

    </div>
</div>

</body>
</html>