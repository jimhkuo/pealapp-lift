package code.comet

import code.lib._
import net.liftweb.http._
import net.liftweb.http.js.JsCmds
import net.liftweb.http.js.JsCmds._

trait MainCometBody extends CometActor {
  val bgp = "% model of an attack-countermeasure tree for resetting a single BGP session\n% based on the paper \"ACT: Towards unifying the constructs of attack and defense trees,\n% by A. Roy, D. S. Kim, and K. S. Trivedi, Security Comm. Networks 2011; 3:1-15\"\n%\n%\n% the model below uses a predicate True, which is always True, to compose sub-policy scores\n%\nPOLICIES\n% probability that attack succeeds\nattack_goal = +((True attack_or1_score)) default 1.0\n%\n% encoding meaning of probability of attack success for OR nodes in ACT model\nattack_or1 = +((True 1.0) (True -1.0*attack_or1_aux_score)) default 1.0\nattack_or1_aux = *((True attack_or1_aux1_score) (True attack_or1_aux2_score)) default 1.0\nattack_or1_aux1 = +((True 1.0) (True -1.0*attack_and1_score)) default 1.0\nattack_or1_aux2 = +((True 1.0) (True -1.0*attack_and2_score)) default 1.0\n%\n% encoding meaning of probability of attach success for AND nodes in ACT model\nattack_and1 = *((True attack_and3_score) (True attack_not1_score)) default 1.0\nattack_and3 = *((True attack_or2_score) (True attack_and6_score)) default 1.0\n%\n% another encoding for an OR node\nattack_or2 = +((True 1.0) (True -1.0*attack_or2_aux_score)) default 1.0\nattack_or2_aux = *((True attack_or2_aux1_score) (True attack_or2_aux2_score)) default 1.0\nattack_or2_aux1 = +((True 1.0) (True -1.0*attack_a111_score)) default 1.0\nattack_or2_aux2 = +((True 1.0) (True -1.0*attack_or3_score)) default 1.0\n%\n% default score of attack leaf is 0.0 as it is not under the scope of a NOT node in ACT model\n% probability of succeeding with this atomic attack is 0.08\nattack_a111 = +((sendRSTmessageToTCPStack 0.08)) default 0.0\n%% another encoding of an OR node, now with three arguments instead of two\nattack_or3 = +((True 1.0) (True -1.0*attack_or3_aux_score)) default 1.0\nattack_or3_aux = *((True attack_or3_aux1_score) (True attack_or3_aux2_score) (True attack_or3_aux3_score)) default 1.0\nattack_or3_aux1 = +((True 1.0) (True -1.0*attack_a1121_score)) default 1.0\nattack_or3_aux2 = +((True 1.0) (True -1.0*attack_a1122_score)) default 1.0\nattack_or3_aux3 = +((True 1.0) (True -1.0*attack_a1123_score)) default 1.0\n%\n% again, default scores of attack leaves are 0.0 as they are not under the scope of a NOT node in ACT model\n% .. and the scores of the sole rule are the probabilities of success of the respective atomic attack\nattack_a1121 = +((notify 0.1)) default 0.0\nattack_a1122 = +((open 0.15)) default 0.0\nattack_a1123 = +((keepAlive 0.2)) default 0.0\n%\n% another encoding for an AND node\nattack_and6 = *((True attack_a12_score) (True attack_not3_score)) default 1.0\n%\n% default score of attack leaf is 0.0 as it is not under scope of a NOT node\n% probability of attack success is 0.1\nattack_a12 = +((TCPsequenceNumberAttack 0.1)) default 0.0\n%\n% coding a gadget for sub-trees T of form \"NOT (detection AND mitigation)\" works as follows:\n% we check whether both detection and mitigation are present (i.e. the predicate in the rule is true),\n% in which case the normal semantics of ACT models applies;\n% if at least one of these is absent, we assume that the NOT node is not under the scope of another NOT node\n% and this is certainly the case for this ACT model;\n% given that, if the parent node of sub-tree T is an AND node (and this is always the case in this ACT model),\n% then the absence of either mitigation or detection results in a default score of 0.0 for the AND node,\n% will in turn results in a score of 1.0 results for the NOT node;\n% this means that within the parent AND node, this outcome has no effect;\n% in the other case, when the parent node is an OR node (not encoded here as it won't occur in the ACT model)\n% the default for the absence of mitigation or detection would be 1.0 for the AND node,\n% and so this would render 0.0 for the NOT node, which has no effect on the parent OR node\nattack_not3 = +((True 1.0) (True -1.0*attack_and7_score)) default 1.0\n%\nattack_and7 = +((TCPsequenceNumberCheck attack_and7_aux1_score)) default 0.0\nattack_and7_aux1 = +((MD5authentication attack_and7_aux2_score)) default 0.0\nattack_and7_aux2 = *((True 0.8) (True 0.5)) default 1.0\n%\n% encoding another such gadget for another NOT node in the ACT model\nattack_not1 = +((True 1.0) (True -1.0*attack_and4_score)) default 1.0\nattack_and4 = +((traceRouteCheck attack_and4_aux1_score)) default 0.0\nattack_and4_aux1 = +((randomizeSequenceNumbers attack_and4_aux2_score)) default 0.0\nattack_and4_aux2 = *((True 0.5) (True 0.6)) default 1.0\n%\n% another encoding of an AND node in the ACT model\nattack_and2 = *((True attack_a2_score) (True attack_not2_score)) default 1.0\n%\n% default score of attack leaf is 0.0 as it is not under the scope of a NOT node in ACT model\n% probability of succeeding with this atomic attack is 0.4\nattack_a2 = +((alterConfigurationViaCompromisedRouter 0.4)) default 0.0\n%\n% encoding another such gadget for another NOT node in the ACT model\nattack_not2 = +((True 1.0) (True -1.0*attack_and5_score)) default 1.0\nattack_and5 = +((routerFirewallAlert attack_and5_aux1_score)) default 0.0\nattack_and5_aux1 = +((secureRouter attack_and5_aux2_score)) default 0.0\nattack_and5_aux2 = *((True 0.7) (True 0.5)) default 1.0\n%\n%%% above we modeled probabilities of attack success, now we want to model attack costs:\n% since we use an SMT solver, we can just specify the cost of each atomic attack and compute\n% the overall cost as the sum of all atomic attacks that did occur, where occurrence means\n% that the predicate of the atomic attack is true in scenario found by the SMT solver\n% \n% we specify costs of atomic attacks, defaults have 0.0 cost: not running an atomic attack costs nothing\n% for example, running attack a1121 costs a unit of 50.0\nattack_cost_a111 = +((sendRSTmessageToTCPStack 50.0)) default 0.0\nattack_cost_a1121 = +((notify 60.0)) default 0.0\nattack_cost_a1122 = +((open 70.0)) default 0.0\nattack_cost_a1123 = +((keepAlive 100.0)) default 0.0\nattack_cost_a12 = +((TCPsequenceNumberAttack 150.0)) default 0.0\nattack_cost_a2 = +((alterConfigurationViaCompromisedRouter 190.0)) default 0.0\n% the overall attack cost is simply the sum of all attacks that occurred\nattack_cost_overall = +((True attack_cost_a111_score) (True attack_cost_a1121_score) (True attack_cost_a1122_score) (True attack_cost_a1123_score) (True attack_cost_a2_score) (True attack_cost_a12_score)) default 0.0\n%\n%\n%%% so far we modeled probability of attack success and attack cost\n%%% next we want to model the impact of attacks; we will specify the impact of atomic attacks first\n% then we follow the semantics of the ACT model by computing the impact for AND and OR nodes;\n% this works since the gadgets for detection/mitigation are the only places that contain NOT nodes\n% and these sub-trees don't have any impact that stems from attacks (although they have an impact\n% in mitigating risk, but this is not analysed here)\n%\n% in the specification of impact for atomic attacks, default scores have 0.0 impact:\n% not running an atomic attack means that said attach has no impact\n% as for the impact, for example, attack a111, when executed has 200.0 impact units \n% attack_impact_a111 = +((sendRSTmessageToTCPStack 200.0)) default 0.0\n% attack_impact_a1121 = +((notify 130.0)) default 0.0\n% attack_impact_a1122 = +((open 100.0)) default 0.0\n% attack_impact_a1123 = +((keepAlive 300.0)) default 0.0\n% attack_impact_a12 = +((TCPsequenceNumberAttack 250.0)) default 0.0\n% attack_impact_a2 = +((alterConfigurationViaCompromisedRouter 275.0)) default 0.0\n%\n% next we compute impact of the or2 policy; this is inductively the maximum of the impact of its sub-trees;\n% this models a worst-case for the system under attack; the impact of AND nodes will be the sum of the\n% impact of its sub-trees; these meanings are the ones used in the ACT model of the cited paper\n% note the fit of our policy semantics: only true predicates contribute to 'max' and default impact is 0.0\n% note also that we incorporated or3 into policy attack_impact_or2 already for sake of compactness\nattack_impact_or2 = max((sendRSTmessageToTCPStack 200.0) (notify 130.0) (open 100.0) (keepAlive 300.0)) default 0.0\n% next we compute the impact for policy and3, which already contains the impact for policy and6 for sake of\n% compactness; as stated above, we use the sum of the impact of the AND node's sub-trees\nattack_impact_and3 = +((True attack_impact_or2_score) (TCPsequenceNumberAttack 250.0)) default 0.0\n% given the structure of the ACT, we can define attack_impact_and1 as the score of attack_impact_and3;\n% this is so since the second argument of that AND node contains a detection/mitigation sub-tree only\n% that does not contribute anything to attack impact, and so we can abstract it away\nattack_impact_and1 = +((True attack_impact_and3_score)) default 0.0\n% the impact for policy and2 is computed similarly, we can ignore its second argument for the same reason,\n% and the first argument is the impact of an atomic attack 'alterConfigurationViaCompromisedRouter'\nattack_impact_and2 = +((alterConfigurationViaCompromisedRouter 275.0)) default 0.0\n% overall impact is that of an OR node; so we use 'max' composition for this policy, 'True' in rules,\n% and let the default score be 0.0 (if no sub-tree had any impact, then this tree won't have any either)\nattack_impact_overall = max((True attack_impact_and1_score) (True attack_impact_and2_score)) default 0.0\n%\nPOLICY_SETS\n% casting the probability of attack success into a policy set\npSet_attack_goal = attack_goal\n% casting the overall cost of an attack into a policy set\npSet_attack_cost_overall =  attack_cost_overall\n% casting the overall impact of an attack into a policy set\npSet_attack_impact_overall =  attack_impact_overall\nCONDITIONS\n% the next definitions cast predicates into conditions and group them into mitigations, detections, and both\n% we also cast the predicate of attack a12 into a condition\nd1 = traceRouteCheck\nd2 = routerFirewallAlert\nd3 = TCPsequenceNumberCheck\nd4 = d1 && d2\nallDetectionsOn = d4 && d3\nm1 = randomizeSequenceNumbers \nm2 = secureRouter\nm3 = MD5authentication\nm4 = m1 && m2\na12 = TCPsequenceNumberAttack\nallMitigationsOn = m4 && m3\nallMitigations_DetectionsOn = allMitigationsOn && allDetectionsOn\n%\n% the number below is the exact probability of attack success, so this condition would be UNSAT if\n% all detection and mitigation measures are in place; but in our model they may be turned OFF by\n% making their guarding predicates false, indeed this condition is here SAT\nc1 = 0.2735807168 < pSet_attack_goal\n% we ask if the probability of attack success can be larger than this bound if all mechanisms are in place\n% this should be UNSAT\naboveBound = 0.2735807168 < pSet_attack_goal\nc2 = aboveBound && allMitigations_DetectionsOn\n% casting the negation of a12 into a condition\na12_not = !a12\n% can probability of attack success still be above 0.2735807167 when TCPsequenceNumberAttack is absent?\n% this should be UNSAT\nc3 = c2 && a12_not\n% maximum possible cost is 620, formulate a condition that cost is less than that (discrete domain)\nnotMaximalCost = pSet_attack_cost_overall <= 619.0\n% can probability of attack success be above 0.2735807167 if cost is not maximum possible?\n% this should be UNSAT\nc4 = c2 && notMaximalCost\n% can probability of attack success be above 0.2735807167 when all mitigation measures are in place?\n% this should be UNSAT\nc5 = c2 && allMitigations_DetectionsOn\n%\n% now we want to explore whether an attacker can succeed with at least a certain probability by also\n% ensuring at least a certain impact and not paying a cost above a certain threshold;\n% we formulate the relevant conditions and then conjoin them for analysis\n%\n% bound on attack success\nminimalSuccess = 0.41199 < pSet_attack_goal\n% bound on impact\nminimalImpact = 549.0 < pSet_attack_impact_overall\n% bound on cost\nmaximalCost = pSet_attack_cost_overall <= 440.0\n% conjoining these conditions\nminimalBounds = minimalImpact && maximalCost\n% the condition to be analyzed, this is SAT such that all three threshold values sit at a SAT/UNSAT\n% boundary: increasing impact by 1.0, decreasing cost by 1.0 or increasing attack success probability by\n% 0.00001 will make this condition UNSAT\nc6 = minimalBounds && minimalSuccess\n%\n% now as ask whether the scenario is c6 is still realizable when detection 'routerFirewallAlert' and\n% mitigation 'secureRouter' are both in place\ng1 = d2 && m2\n% with this pair of mitigation and detection in place, the condition is now UNSAT\nc7 = c6 && g1\nDOMAIN_SPECIFICS\n(assert True)\nANALYSES\nname1 = satisfiable? c1\nname2 = satisfiable? c2\nname3 = satisfiable? c3\nname4 = satisfiable? c4\nname5 = satisfiable? c5\nname6 = satisfiable? c6\nname7 = satisfiable? c7"
  val bgpUncertainties = "% model of an attack-countermeasure tree for resetting a single BGP session\n% based on the paper \"ACT: Towards unifying the constructs of attack and defense trees,\n% by A. Roy, D. S. Kim, and K. S. Trivedi, Security Comm. Networks 2011; 3:1-15\"\n%\n%\n% the model below uses a predicate True, which is always True, to compose sub-policy scores\n% this model is a modification of one we studied earlier, but where we now add uncertainty\n% to some probabilities, costs, and impact;\n% to recall, we can add to a score an interval [l,u] such that l <= u which non-deterministically\n% adds a value from that interval to the score in order to find a scenario if one exists;\n% note that most often l is negative, but at times we chose l to be 0.0, for example to express\n% that the uncertainty in an impact is such that it could only be greater or equal to the stated one\nPOLICIES\n% probability that attack succeeds\nattack_goal = +((True attack_or1_score)) default 1.0\n%\n% encoding meaning of probability of attack success for OR nodes in ACT model\nattack_or1 = +((True1 1.0) (True2 -1.0*attack_or1_aux_score)) default 1.0\nattack_or1_aux = *((True1 attack_or1_aux1_score) (True2 attack_or1_aux2_score)) default 1.0\nattack_or1_aux1 = +((True1 1.0) (True2 -1.0*attack_and1_score)) default 1.0\nattack_or1_aux2 = +((True1 1.0) (True2 -1.0*attack_and2_score)) default 1.0\n%\n% encoding meaning of probability of attach success for AND nodes in ACT model\nattack_and1 = *((True1 attack_and3_score) (True2 attack_not1_score)) default 1.0\nattack_and3 = *((True1 attack_or2_score) (True2 attack_and6_score)) default 1.0\n%\n% another encoding for an OR node\nattack_or2 = +((True1 1.0) (True2 -1.0*attack_or2_aux_score)) default 1.0\nattack_or2_aux = *((True1 attack_or2_aux1_score) (True2 attack_or2_aux2_score)) default 1.0\nattack_or2_aux1 = +((True1 1.0) (True2 -1.0*attack_a111_score)) default 1.0\nattack_or2_aux2 = +((True1 1.0) (True2 -1.0*attack_or3_score)) default 1.0\n%\n% default score of attack leaf is 0.0 as it is not under the scope of a NOT node in ACT model\n% probability of succeeding with this atomic attack is 0.08\nattack_a111 = +((sendRSTmessageToTCPStack 0.08)) default 0.0\n%% another encoding of an OR node, now with three arguments instead of two\nattack_or3 = +((True1 1.0) (True2 -1.0*attack_or3_aux_score)) default 1.0\nattack_or3_aux = *((True1 attack_or3_aux1_score) (True2 attack_or3_aux2_score) (True3 attack_or3_aux3_score)) default 1.0\nattack_or3_aux1 = +((True1 1.0) (True2 -1.0*attack_a1121_score)) default 1.0\nattack_or3_aux2 = +((True1 1.0) (True2 -1.0*attack_a1122_score)) default 1.0\nattack_or3_aux3 = +((True1 1.0) (True2 -1.0*attack_a1123_score)) default 1.0\n%\n% again, default scores of attack leaves are 0.0 as they are not under the scope of a NOT node in ACT model\n% .. and the scores of the sole rule are the probabilities of success of the respective atomic attack;\n% the uncertainty is encoded as discussed above; for example for attack leaf a1121 the score for notify is\n% really in the interval [0.08,0.11], etc.\nattack_a1121 = +((notify 0.1 [-0.02,0.01])) default 0.0\nattack_a1122 = +((open 0.15 [-0.01,0.02])) default 0.0\nattack_a1123 = +((keepAlive 0.2 [-0.05,0.05])) default 0.0\n%\n% another encoding for an AND node\nattack_and6 = *((True1 attack_a12_score) (True2 attack_not3_score)) default 1.0\n%\n% default score of attack leaf is 0.0 as it is not under scope of a NOT node\n% probability of attack success is 0.1\nattack_a12 = +((TCPsequenceNumberAttack 0.1 [-0.6,0.01])) default 0.0\n%\n% coding a gadget for sub-trees T of form \"NOT (detection AND mitigation)\" works as follows:\n% we check whether both detection and mitigation are present (i.e. the predicate in the rule is true),\n% in which case the normal semantics of ACT models applies;\n% if at least one of these is absent, we assume that the NOT node is not under the scope of another NOT node\n% and this is certainly the case for this ACT model;\n% given that, if the parent node of sub-tree T is an AND node (and this is always the case in this ACT model),\n% then the absence of either mitigation or detection results in a default score of 0.0 for the AND node,\n% will in turn results in a score of 1.0 results for the NOT node;\n% this means that within the parent AND node, this outcome has no effect;\n% in the other case, when the parent node is an OR node (not encoded here as it won't occur in the ACT model)\n% the default for the absence of mitigation or detection would be 1.0 for the AND node,\n% and so this would render 0.0 for the NOT node, which has no effect on the parent OR node\nattack_not3 = +((True 1.0) (True -1.0*attack_and7_score)) default 1.0\n%\nattack_and7 = +((TCPsequenceNumberCheck attack_and7_aux1_score)) default 0.0\nattack_and7_aux1 = +((MD5authentication attack_and7_aux2_score)) default 0.0\nattack_and7_aux2 = *((True1 0.8 [-0.2,0.1]) (True2 0.5 [-0.2,0.2])) default 1.0\n%\n% encoding another such gadget for another NOT node in the ACT model\nattack_not1 = +((True1 1.0) (True2 -1.0*attack_and4_score)) default 1.0\nattack_and4 = +((traceRouteCheck attack_and4_aux1_score)) default 0.0\nattack_and4_aux1 = +((randomizeSequenceNumbers attack_and4_aux2_score)) default 0.0\nattack_and4_aux2 = *((True1 0.5 [-0.1,0.1]) (True2 0.6 [-0.1,0.1])) default 1.0\n%\n% another encoding of an AND node in the ACT model\nattack_and2 = *((True1 attack_a2_score) (True2 attack_not2_score)) default 1.0\n%\n% default score of attack leaf is 0.0 as it is not under the scope of a NOT node in ACT model\n% probability of succeeding with this atomic attack is 0.4\nattack_a2 = +((alterConfigurationViaCompromisedRouter 0.4 [-0.1,0.2])) default 0.0\n%\n% encoding another such gadget for another NOT node in the ACT model\nattack_not2 = +((True1 1.0) (True2 -1.0*attack_and5_score)) default 1.0\nattack_and5 = +((routerFirewallAlert attack_and5_aux1_score)) default 0.0\nattack_and5_aux1 = +((secureRouter attack_and5_aux2_score)) default 0.0\nattack_and5_aux2 = *((True1 0.7 [-0.1,0.2]) (True2 0.5)) default 1.0\n%\n%%% above we modeled probabilities of attack success, now we want to model attack costs:\n% since we use an SMT solver, we can just specify the cost of each atomic attack and compute\n% the overall cost as the sum of all atomic attacks that did occur, where occurrence means\n% that the predicate of the atomic attack is true in scenario found by the SMT solver\n% \n% we specify costs of atomic attacks, defaults have 0.0 cost: not running an atomic attack costs nothing\n% for example, running attack a1121 costs a unit of 50.0\nattack_cost_a111 = +((sendRSTmessageToTCPStack 50.0 [-10.0,5.0])) default 0.0\nattack_cost_a1121 = +((notify 60.0 [-20.0,10.0])) default 0.0\nattack_cost_a1122 = +((open 70.0 [-5.0,20.0])) default 0.0\nattack_cost_a1123 = +((keepAlive 100.0 [0.0,25.0])) default 0.0\nattack_cost_a12 = +((TCPsequenceNumberAttack 150.0 [-30.0,10.0])) default 0.0\nattack_cost_a2 = +((alterConfigurationViaCompromisedRouter 190.0 [0.0,20.0])) default 0.0\n% the overall attack cost is simply the sum of all attacks that occurred\nattack_cost_overall = +((True1 attack_cost_a111_score) (True2 attack_cost_a1121_score) (True3 attack_cost_a1122_score) (True4 attack_cost_a1123_score) (True5 attack_cost_a2_score) (True6 attack_cost_a12_score)) default 0.0\n%\n%\n%%% so far we modeled probability of attack success and attack cost\n%%% next we want to model the impact of attacks; we will specify the impact of atomic attacks first\n% then we follow the semantics of the ACT model by computing the impact for AND and OR nodes;\n% this works since the gadgets for detection/mitigation are the only places that contain NOT nodes\n% and these sub-trees don't have any impact that stems from attacks (although they have an impact\n% in mitigating risk, but this is not analysed here)\n%\n% in the specification of impact for atomic attacks, default scores have 0.0 impact:\n% not running an atomic attack means that said attach has no impact\n% as for the impact, for example, attack a111, when executed has 200.0 impact units \n% attack_impact_a111 = +((sendRSTmessageToTCPStack 200.0 [0.0,30.0])) default 0.0\n% attack_impact_a1121 = +((notify 130.0 [-10.0,10.0])) default 0.0\n% attack_impact_a1122 = +((open 100.0 [-20.0,30.0])) default 0.0\n% attack_impact_a1123 = +((keepAlive 300.0 [-50.0,60.0])) default 0.0\n% attack_impact_a12 = +((TCPsequenceNumberAttack 250.0 [0.0,10.0])) default 0.0\n% attack_impact_a2 = +((alterConfigurationViaCompromisedRouter 275.0 [-10.0,20.0])) default 0.0\n%\n% next we compute impact of the or2 policy; this is inductively the maximum of the impact of its sub-trees;\n% this models a worst-case for the system under attack; the impact of AND nodes will be the sum of the\n% impact of its sub-trees; these meanings are the ones used in the ACT model of the cited paper\n% note the fit of our policy semantics: only true predicates contribute to 'max' and default impact is 0.0\n% note also that we incorporated or3 into policy attack_impact_or2 already for sake of compactness\nattack_impact_or2 = max((sendRSTmessageToTCPStack 200.0) (notify 130.0) (open 100.0) (keepAlive 300.0)) default 0.0\n% next we compute the impact for policy and3, which already contains the impact for policy and6 for sake of\n% compactness; as stated above, we use the sum of the impact of the AND node's sub-trees\nattack_impact_and3 = +((True attack_impact_or2_score) (TCPsequenceNumberAttack 250.0)) default 0.0\n% given the structure of the ACT, we can define attack_impact_and1 as the score of attack_impact_and3;\n% this is so since the second argument of that AND node contains a detection/mitigation sub-tree only\n% that does not contribute anything to attack impact, and so we can abstract it away\nattack_impact_and1 = +((True attack_impact_and3_score)) default 0.0\n% the impact for policy and2 is computed similarly, we can ignore its second argument for the same reason,\n% and the first argument is the impact of an atomic attack 'alterConfigurationViaCompromisedRouter'\nattack_impact_and2 = +((alterConfigurationViaCompromisedRouter 275.0)) default 0.0\n% overall impact is that of an OR node; so we use 'max' composition for this policy, 'True' in rules,\n% and let the default score be 0.0 (if no sub-tree had any impact, then this tree won't have any either)\nattack_impact_overall = max((True1 attack_impact_and1_score) (True2 attack_impact_and2_score)) default 0.0\n%\nPOLICY_SETS\n% casting the probability of attack success into a policy set\npSet_attack_goal = attack_goal\n% casting the overall cost of an attack into a policy set\npSet_attack_cost_overall =  attack_cost_overall\n% casting the overall impact of an attack into a policy set\npSet_attack_impact_overall =  attack_impact_overall\nCONDITIONS\n% the next definitions cast predicates into conditions and group them into mitigations, detections, and both\n% we also cast the predicate of attack a12 into a condition\nd1 = traceRouteCheck\nd2 = routerFirewallAlert\nd3 = TCPsequenceNumberCheck\nd4 = d1 && d2\nallDetectionsOn = d4 && d3\nm1 = randomizeSequenceNumbers \nm2 = secureRouter\nm3 = MD5authentication\nm4 = m1 && m2\na12 = TCPsequenceNumberAttack\nallMitigationsOn = m4 && m3\nallMitigations_DetectionsOn = allMitigationsOn && allDetectionsOn\n%\n% the number below is the exact probability of attack success, so this condition would be UNSAT if\n% all detection and mitigation measures are in place; but in our model they may be turned OFF by\n% making their guarding predicates false, indeed this condition is here SAT\nc1 = 0.2735807168 < pSet_attack_goal\n% we ask if the probability of attack success can be larger than this bound if all mechanisms are in place\n% this would be UNSAT for all uncertainties set to 0.0 (meaning there would be no uncertainty from [l,u]);\n% but the presence of these intervals for attack success probabilities, impact, and cost means that in \n% this PEALT model all conditions are now satisfiable\naboveBound = 0.2735807168 < pSet_attack_goal\nc2 = aboveBound && allMitigations_DetectionsOn\n% casting the negation of a12 into a condition\na12_not = !a12\n% can probability of attack success still be above 0.2735807167 when TCPsequenceNumberAttack is absent?\n% this should be UNSAT if all uncertainties are set to 0.0 but it is SAT in the presence of such uncertainty\nc3 = c2 && a12_not\n% maximum possible cost is 620, formulate a condition that cost is less than that (discrete domain)\nnotMaximalCost = pSet_attack_cost_overall <= 619.0\n% can probability of attack success be above 0.2735807167 if cost is not maximum possible?\n% this should be UNSAT if all uncertainties are set to 0.0 but it is SAT in the presence of such uncertainty\nc4 = c2 && notMaximalCost\n% can probability of attack success be above 0.2735807167 when all mitigation measures are in place?\n% this should be UNSAT if all uncertainties are set to 0.0 but it is SAT in the presence of such uncertainty\nc5 = c2 && allMitigations_DetectionsOn\n%\n% now we want to explore whether an attacker can succeed with at least a certain probability by also\n% ensuring at least a certain impact and not paying a cost above a certain threshold;\n% we formulate the relevant conditions and then conjoin them for analysis\n%\n% bound on attack success: this used to be 0.41199 for the model without uncertainties;\n% the presence of uncertainty increases the probability of attack success by the difference of these\n% two numbers\nminimalSuccess = 0.61099 < pSet_attack_goal\n% bound on impact: this is as without uncertainty, interestingly enough\nminimalImpact = 549.0 < pSet_attack_impact_overall\n% bound on cost: this used to be 440.0 in the model without uncertainties\nmaximalCost = pSet_attack_cost_overall <= 410.0\n% conjoining these conditions\nminimalBounds = minimalImpact && maximalCost\n% the condition to be analyzed, this is SAT such that all three threshold values sit at a SAT/UNSAT\n% boundary: increasing impact by 1.0, decreasing cost by 1.0 or increasing attack success probability by\n% 0.00001 will make this condition UNSAT\nc6 = minimalBounds && minimalSuccess\n%\n% now as ask whether the scenario is c6 is still realizable when detection 'routerFirewallAlert' and\n% mitigation 'secureRouter' are both in place\ng1 = d2 && m2\n% with this pair of mitigation and detection in place, the condition is UNSAT ...\n% ... even in the presence of the above uncertainties\nc7 = c6 && g1\nDOMAIN_SPECIFICS\n(assert True)\n(assert True1)\n(assert True2)\n(assert True3)\n(assert True4)\n(assert True5)\n(assert True6)\nANALYSES\nname1 = satisfiable? c1\nname2 = satisfiable? c2\nname3 = satisfiable? c3\nname4 = satisfiable? c4\nname5 = satisfiable? c5\nname6 = satisfiable? c6\nname7 = satisfiable? c7"
  val socialNetworkExample = "POLICIES\n% policy that accumulates trust indicators for a PayPal type payment transaction\nb1 = + ((lowCostTransaction 0.3) (enoughMutualFriends 0.1) (enoughMutualFriendsNormalized 0.2)) default 0\n% policy that extracts the worst possible signal for distrusting such a transaction\nb2 = min ((highCostTransaction 0.1) (aFriendOfAliceUnfriendedBob 0.2) (aFriendOfAliceVouchesForBob 0.6)) default 1\nPOLICY_SETS\n% policy set that conservatively (given threshold type th < cond below) combines both policies above\npSet1 = min(b1,b2)\nCONDITIONS\n% asking whether combined trust score is above a certain threshold\ncond1 = 0.5 < pSet1\n% asking whether the combined trust score is above a higher such threshold\ncond2 = 0.6 < pSet1\nDOMAIN_SPECIFICS\n% the amount of the pondered online transaction\n(declare-const amountAlicePays Real)\n% the number of friends that payer and payee share\n(declare-const numberOfMutualFriends Real)\n% number of friends of payee\n(declare-const numberOfBobsFriends Real)\n% definition of what a low cost transaction represents\n(assert (= lowCostTransaction (< amountAlicePays 100)))\n% definition of what a high cost transaction represents\n% note that these transaction types are not logical negations of each other\n(assert (= highCostTransaction (< 1000 amountAlicePays)))\n% definition of that it means to have enough mutual friends for this intended transaction\n(assert (= enoughMutualFriends (< 4 numberOfMutualFriends)))\n% a variant of such a definition that may be more resilient to abnormal values, e.g. for celebrities\n(assert (= enoughMutualFriendsNormalized (< numberOfBobsFriends (* 100 numberOfMutualFriends))))\nANALYSES\n% asking whether the combined trust score can exceed threshold 0.5\nname1 = satisfiable? cond1\n% asking whether the above condition is always true, which would suggest a specification error\nname2 = always_true? cond1\n% asking whether the above condition is always false, which would suggest a specification error\nname3 = always_false? cond1\n% asking whether one threshold behavior implies another, should be the case as 0.5 < 0.6 holds\nname4 = implies? cond2 cond1\n% asking whether both threshold behaviors are equivalent, this may be true or false in general\n% but it is false in this instance\nname5 = equivalent? cond1 cond2"
  val carRentalExample = "POLICIES\n% policy capturing risk of financial loss dependent on type of rented car\nb1 = max ((isLuxuryCar 150000) (isSedan 60000) (isCompact 30000)) default 50000\n% policy capturing trust in rentee dependent on type of his or her driving license\n% trust score for 'hasOtherLicense' contains non-deterministic uncertainty and so is in [0.3,0.5]\nb2 = min ((hasUSLicense 0.9) (hasUKLicense 0.6) (hasEULicense 0.7) (hasOtherLicense 0.4 [-0.1,0.1])) default 0\n% policy that captures potential risk dependent on type of intended car usage\n% this policy happens not to be used in the conditions below\nb3 = max ((someOffRoadDriving 0.8) (onlyCityUsage 0.4) (onlyLongDistanceUsage 0.2) (mixedUsage 0.25)) default 0.3\n% policy that accumulates some signale that may serve as additional trust indicators\nb4 = + ((accidentFreeForYears 0.05*x) (speaksEnglish 0.05) (travelsAlone -0.2) (femaleDriver 0.1)) default 0\n% the next policy is just defining a 'constant' -1, to be used as sub-expression in a policy set\nb_minOne = + () default -1\nPOLICY_SETS\n% policy set that 'converts' the trust expressed in b2 into risk\npSet0 = +(b2,b_minOne)\n% policy set that multiplies risk with potential financial loss\npSet1 = *(b1,pSet0)\n% casting policy p4 into a policy set\npSet_b4 = b4\nCONDITIONS\n% condition that the risk aware potential financial loss is below a certain bound\ncond1 = pSet1 <= 50000\n% condition that the accumulated trust is above a certain threshold\ncond2 = 0.4 < pSet_b4\n% condition that insists that two previous conditions have to hold\ncond3 = cond1 && cond2\n% variant of condition cond2 with a higher threshold\ncond4 = 0.6 < pSet_b4\n% variant of condition cond3 for that higher threshold\ncond5 = cond1 && cond4\nDOMAIN_SPECIFICS\n% real x models the number of years driven without accident, has to be non-negative and is 'truncated' at value 10\n(assert (and (<= 0 x) (<= x 10)))\n% capturing a company policy: luxury cars must not be used for off road driving \n(assert (or (not isLuxuryCar) (not someOffRoadDriving)))\n% capturing that the different types of rental cars are mutually exclusive\n(assert (and (implies isLuxuryCar (and (not isSedan) (not isCompact))) (implies isSedan (and (not isLuxuryCar) (not isCompact))) (implies isCompact (and (not isSedan) (not isLuxuryCar)))))\n% capturing that cars that are only used in cities are not used in a mixed sense\n(assert (implies onlyCityUsage (not mixedUsage)))\n% capturing that cars used only for longdistance driving are not used in a mixed sense\n(assert (implies onlyLongDistanceUsage (not mixedUsage)))\n% capturing domain constraints (or company policy?) that city driving cannot happen off road\n(assert (implies onlyCityUsage (not someOffRoadDriving)))\n% capturing that cars used only for longdistance driving must drive off road\n(assert (implies onlyLongDistanceUsage (not someOffRoadDriving)))\nANALYSES\n% is condition cond3 satisfiable?\nname1 = satisfiable? cond3\n% is condition cond3 always true? this would suggest a specification error\nname2 = always_true? cond3\n% is condition cond3 always false? this also would suggest a specification error\nname3 = always_false? cond3\n% is condition cond5 satisfiable?\nname4 = satisfiable? cond5\n% are conditions cond3 and cond5 equivalent?\nname5 = equivalent? cond3 cond5"
  val fireFaultTreeExample = "POLICIES\n% compute combined probability of the occurrence of three types of fuel\n% policies naturally encode that absent fuel types don't contribute any probability \nfuel = +((gasoline 0.1) (coal 0.02) (wood 0.09)) default 0\n% compute combined probability of the occurrence of three types of ignition\nignition = +((matches 0.2) (gas_stove 0.1) (electrical_sparc 0.05)) default 0\n% oxygen is present with probability 1\noxygen = +() default 1\n% multiply probabilities of presence of fuel, ignition source, and oxygen\n% this makes use of auxiliary predicates such as 'Fuel' that indicate the presence of that resource\nfire = *((True fuel_score) (True ignition_score) (True oxygen_score)) default 1\nPOLICY_SETS\n% cast failure probability policy into a policy set\npSet1 = fire\nCONDITIONS\n% asks whether failure probability can be above a certain value\ncond1 = 0.0734 < pSet1\n% asks whether failure probability can be above a slightly higher value\ncond2 = 0.0735 < pSet1\n% asks if failure probability can be below a certain value\ncond3 = pSet1 <= 0.00735\n% casting predicate 'gas_stove' into a condition\nstove_cond = gas_stove\n% negating a condition\ncond4 = !stove_cond\n% asks whether the failure probability can be above 0.0734 when gas_stove is absent\ncond5 = cond4 && cond1\n% asks whether the failure probability can be zero\ncond6 = pSet1 <= 0\nDOMAIN_SPECIFICS\n(assert True)\n% we also model that coal can only be lit by a gas_stove, not by matches, and not by electrical sparcs\n% again, there is the issue of whether or not to make this a global assumption or not\n(assert (implies coal gas_stove))\nANALYSES\n% cond1 can be made true: this witnesses that the failure probability can exceed a critical value\nname1 = satisfiable? cond1\n% cond1 can be false, meaning that the failure probability won't exceed a critical value in all scenarios\nname2 = always_true? cond1\n% cond1 can be made true: there is at least one scenario in which the failure probability exceeds a critical value\nname3 = always_false? cond1\n% cond2 cannot be made true: the failure probability cannot exceed a (higher) critical value\nname4 = satisfiable? cond2\n% cond5 cannot be made true: there is no scenario in which (1) the gas stove is not an ignition source and \n% (2) the failure probability exceeds a critical value\nname5 = satisfiable? cond5\n% failure probability can indeed to zero\nname6 = satisfiable? cond6"
  var inputPolicies = socialNetworkExample
  var majorityVotingCount = 10
  var randomModelParam = "5, 5, 4, 3, 2, 7, 0.5, 0.1"
  var randomModelWithRangeParam = "2, 4, 3, 2, 1, 6, 0.5, 0.1"
  var randomModelParamWithDomain = "2, 3, 1, 1, 1, 9, 0.5, 0.1"

  def generateHtmlContents: RenderOut = {
      <div>
        <form class="lift:form.ajax">
          <div class="row">
            <div class="col-sm-12">
            <h4>1. Generate PEALT input:</h4>
            <h6>Enter policies, policy sets, conditions and analyses in the text area or generate such input by clicking one of the blue buttons.</h6>
            <div>
              {SHtml.ajaxButton("Social Network Access Control example", () => {this ! SocialNetworkAccessControl; _Noop}, "class" -> "btn btn-primary btn-sm", "style" -> "margin:2px;")}
              {SHtml.ajaxButton("Majority-voting sample, n =", () => {this ! MajorityVoting; _Noop}, "class" -> "btn btn-primary btn-sm", "style" -> "margin:2px;")}
              {SHtml.ajaxText(majorityVotingCount.toString, s => {majorityVotingCount = s.toInt; _Noop}, "id" -> "n", "size" -> "10")}
            </div>
            <div>
              {SHtml.ajaxButton("Random sample without domain specifics: n, m_min, m_max, m_+, m_*, p, th, delta", () => {this ! GenerateConstantScore; _Noop}, "class" -> "btn btn-primary btn-sm", "style" -> "margin:2px;") }
              {SHtml.ajaxText(randomModelParam, s => {randomModelParam = s; _Noop}, "id" -> "r", "size" -> "30")}
            </div>
            <div>
              {SHtml.ajaxButton("Random sample with domain specifics: n, m_min, m_max, m_+, m_*, p, th, delta", () => {this ! GenerateConstantScoreWithDomainSpecifics; _Noop}, "class" -> "btn btn-primary btn-sm", "style" -> "margin:2px;")}
              {SHtml.ajaxText(randomModelParamWithDomain, s => {randomModelParamWithDomain = s; _Noop}, "id" -> "r", "size" -> "30")}
            </div>
            <div>
              {SHtml.ajaxButton("Car Rental Risks example", () => {this ! CarRentalRisks; _Noop}, "class" -> "btn btn-info btn-sm", "style" -> "margin:2px;")}
              {SHtml.ajaxButton("Fire Fault Tree example", () => {this ! FireFaultTree; _Noop}, "class" -> "btn btn-info btn-sm", "style" -> "margin:2px;")}
              {SHtml.ajaxButton("BGP Reset Session example", () => {this ! BGP; _Noop}, "class" -> "btn btn-info btn-sm", "style" -> "margin:2px;")}
              {SHtml.ajaxButton("BGP Reset Session uncertainties example", () => {this ! BGPUncertainties; _Noop}, "class" -> "btn btn-info btn-sm", "style" -> "margin:2px;")}

            </div>
            <div>
              {SHtml.ajaxButton("Random sample with ranges: n, m_min, m_max, m_+, m_*, p, th, delta", () => {this ! GenerateScoresWithRange; _Noop}, "class" -> "btn btn-info btn-sm", "style" -> "margin:2px;")}
              {SHtml.ajaxText(randomModelWithRangeParam, s => {randomModelWithRangeParam = s; _Noop}, "id" -> "r", "size" -> "30")}
            </div>
            <div>
              {SHtml.ajaxButton("Clear text area", () => {this ! Clear; _Noop}, "class" -> "btn btn-warning btn-sm", "style" -> "margin:2px;")}
              {SHtml.ajaxButton("Download text", () => {this ! DownloadClicked; JsCmds.RedirectTo("download")}, "class" -> "btn btn-warning btn-sm", "style" -> "margin:2px;")}
            </div>
            </div>
          </div>
          <div class="row" style="margin-top: 5px">
            <div class="col-sm-7">
              {SHtml.ajaxTextarea(inputPolicies, s => {inputPolicies = s; _Noop}, "id" -> "policies", "class" -> "form-control", "rows" -> "20")}
            </div>
            <div class="col-sm-5">
              <h4>2. Analyze PEALT input:</h4>
              <h6>Choose method of code generation for analyses. Then choose analysis option by clicking any of the green buttons.</h6>
              <ul class="nav nav-tabs">
                <li class="active"><a href="#explicit" class="nonScore" data-toggle="tab">Non-negative, constant scores</a></li>
                <li><a href="#extended" data-toggle="tab" class="generalScore">General scores</a></li>
              </ul>
            </div>
            <div class="tab-content">
              <div class="tab-pane active" id="explicit">
                <div class="col-sm-5">
                  {SHtml.ajaxButton("Display results of all analyses in pretty printed form and perform independent certification of results", () => {this ! WrappedAction(SynthesisAndCallZ3QuietAnalysis); _Noop}, "class" -> "btn btn-primary btn-sm", "style" -> "margin:2px;")}
                  {SHtml.ajaxButton("Generate, show, and run Z3 code; display results in pretty-printed and raw form", () => {this ! WrappedAction(RunAndCertifyExplicitResults); _Noop}, "class" -> "btn btn-primary btn-sm", "style" -> "margin:2px;")}
                  {SHtml.ajaxButton("Generate, show, and run Z3 code, display results in raw Z3 form", () => {this ! WrappedAction(ExplicitSynthesisAndCallZ3); _Noop}, "class" -> "btn btn-primary btn-sm", "style" -> "margin:2px;")}
                </div>
              </div>
              <div class="tab-pane" id="extended">
                <div class="col-sm-5">
                  {SHtml.ajaxButton("Display results of all analyses in pretty printed form and perform independent certification of results", () => {this ! WrappedAction(SynthesisExtendedAndCallZ3QuietAnalysis); _Noop}, "class" -> "btn btn-info btn-sm", "style" -> "margin:2px;")}
                  {SHtml.ajaxButton("Generate, show, and run Z3 code; display results in pretty-printed and raw form", () => {this ! WrappedAction(RunAndCertifyExtendedResults); _Noop}, "class" -> "btn btn-info btn-sm", "style" -> "margin:2px;")}
                  {SHtml.ajaxButton("Generate, show, and run Z3 code, display results in raw Z3 form", () => {this ! WrappedAction(ExtendedSynthesisAndCallZ3); _Noop}, "class" -> "btn btn-info btn-sm", "style" -> "margin:2px;")}
                </div>
              </div>
            </div>
          </div>
          <div class="row" style="margin-top: 2px">
            <div class="col-sm-12" id="result"></div>
          </div>
        </form>
      </div>
    }
}
